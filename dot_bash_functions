# Global
function extract {
  if [ -f $1 ] ; then
      case $1 in
          *.tar.bz2)   tar xvjf $1    ;;
          *.tar.gz)    tar xvf $1    ;;
          *.bz2)       bunzip2 $1     ;;
          *.rar)       rar x $1       ;;
          *.gz)        gunzip $1      ;;
          *.tar)       tar xvf $1     ;;
          *.tbz2)      tar xvjf $1    ;;
          *.tgz)       tar xvzf $1    ;;
          *.zip)       unzip $1       ;;
          *.Z)         uncompress $1  ;;
          *.7z)        7z x $1        ;;
          *.xz)        unxz $1        ;;
          *)           echo "don't know how to extract '$1'..." ;;
      esac
  else
      echo "'$1' is not a valid file!"
  fi
}

function replace {
    find . -type f -exec sed -i "s/$1/$2/g" {} +
}
notif () {
    $@ && notify-send "Job finished!"|| notify-send "Job failed!"
}

# Tmux
function tns {
    label=$(basename $PWD)
    if [ ! -z $1 ]; then
        label=$1
    fi
    tmux new-session -d -s $label && [[ -n "$TMUX" ]] \
        && tmux switch-client -t $label \
        || tmux attach
}
# Docker
#docker remove all
function dra {
    docker rm $(docker ps -aq)
}
#docker stop all
function dsa {
    docker stop $(docker ps -aq)
}
#docker prune all
function dpa {
    echo stop containers
    dsa
    echo remove containers
    dra
    echo prune networks..
    docker network prune -f
    echo prune volumes..
    docker volume prune -f
}

# Fzf
function gfb {
    # git checkout $(git branch | fzf | awk '{print $2}')
    local tags branches target
      tags=$(
    git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}') || return
      branches=$(
    git branch --all | grep -v HEAD |
    sed "s/.* //" | sed "s#remotes/[^/]*/##" |
    sort -u | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}') || return
      target=$(
    (echo "$tags"; echo "$branches") |
        fzf --no-hscroll --no-multi --delimiter="\t" -n 2 \
            --ansi --preview="git log -200 --pretty=format:%s $(echo {+2..} |  sed 's/$/../' )" ) || return
      git checkout $(echo "$target" | awk '{print $2}')
}

function scratch {
    ${EDITOR} $(openssl rand -base64 10 | tr -dc 'a-zA-Z')
 }

## Docker fzf completion
export DOCKER_FZF_PREFIX="--bind ctrl-a:select-all,ctrl-d:deselect-all,ctrl-t:toggle-all"

_fzf_complete_docker_run_post() {
    awk '{print $1":"$2}'
}

_fzf_complete_docker_run () {
    _fzf_complete "$DOCKER_FZF_PREFIX -m --header-lines=1" "$@" < <(
        docker images
    )
}

_fzf_complete_docker_common_post() {
    awk -F"\t" '{print $1}'
}

_fzf_complete_docker_common () {
    _fzf_complete "$DOCKER_FZF_PREFIX --reverse -m" "$@" < <(
        docker images --format "{{.Repository}}:{{.Tag}}\t {{.ID}}"
    )
}

_fzf_complete_docker_container_post() {
    awk '{print $NF}'
}

_fzf_complete_docker_container () {
    _fzf_complete "$DOCKER_FZF_PREFIX -m --header-lines=1" "$@" < <(
        docker ps -a
    )
}


_fzf_complete_docker() {
    local cur prev words cword
    _get_comp_words_by_ref -n : cur prev words cword

    if ! type _docker > /dev/null 2>&1; then
        _completion_loader "$@"
        complete -F _fzf_complete_docker -o default -o bashdefault docker
    fi

    local counter=1
    while [ $counter -lt $cword ]; do
        case "${words[$counter]}" in
            run)
                _fzf_complete_docker_run "$@"
                return
            ;;
            exec|rm)
                _fzf_complete_docker_container "$@"
                return
            ;;
            save|load|push|pull|tag|rmi)
                _fzf_complete_docker_common "$@"
                return
            ;;
        esac
        (( counter++ ))
    done
    _fzf_handle_dynamic_completion docker "$@"
}

export _fzf_orig_completion_docker=_docker
complete -F _fzf_complete_docker -o default -o bashdefault docker
